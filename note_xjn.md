### Chapter 6: Pseudo-Rectilinear Regions的凸四边形最优剖分算法

这部分介绍上一章介绍的Pseudo-Rectilinear Regions最优剖分算法的实现。

算法的时间复杂度下界为 $O(nlog n)$。算法的输入为组成多边形区域的多个多边形的链表，每个多边形由一组按顺时针顺序或者逆时针顺序排列的顶点组成。每个顶点的x坐标和y坐标都是整数值。同时，假设没有任意两条边交叉。

而验证一个多边形区域为Pseudo-Rectilinear Region的算法在[SH]这篇论文中可以找到，算法复杂度为 $O(nlog n)$。

算法的结果为一系列用于剖分的四边形，每个四边形由顺时针排列的四个顶点组成。

对于这样一个问题：找到一条左边 $(u, v)$，满足 $v$ 的右邻居在一条右边上。据上一章所讲，如果全部的左边按照右节点的x坐标进行排序，最靠右的左边的右顶点的右邻居一定在一条右边上。更进一步，当根据最后一条左边确定下来的凸四边形被删掉的时候，所有的左边都消失了，然后，最多有两条新的左边会被创建出来。

接下来，对于找右邻居的问题。在算法的过程中，右邻居有可能改变。定义顶点 $v$ 的initial right neighbour为，$v$ 节点右边节点中最靠左，同时与 $v$ 并没有通过倾斜边相连。

#### 引理 5

设删掉根据点对 $(u, v), (r, s)$ 确定的凸四边形后得到的一组不相交的pseudo-rectilinear regions为 $P'$ ，其中 $(u, v)$ 是一条左边，节点 $u$ 的x坐标小于 $v$ 的x坐标，$v$的右邻居为 $r$，而且 $(r, s)$ 是一条右边。如果 $v$ 是 $P'$ 中最右边的一个节点，那么 $v$ 在 $P'$ 的右邻居就是区域 $P$ 的 initial right neighbour。

对于一个给定的pseudo-rectilinear region，如果initial right neighbours的结果已经计算出来后，那么在算法中不需要再计算节点的右邻居。

#### 算法

步骤I：验证多边形区域 $P$ 为pseudo-rectilinear，找到 $P$ 中的 initial right neighbours。然后创建 $P$ 的左边的列表 $L$，根据右节点的 $x$ 坐标进行排序。

步骤II：重复以下步骤直到 $L$ 为空。

1. 从 $L$ 中删掉最后一个左边 $(u, v)$，其中 $u$ 的 $x$ 小于 $v$；
2. 令 $r$ 为节点 $v$ 的initial right neighbour，而且节点 $s$ 与 $r$ 通过一条斜边直接相连；
3. 根据边 $(u, v)$, $(r, s)$ 生成四边形的思路为：令 $u'$ 为节点 $u, v$中 $y$ 坐标较小的一个，$v'$ 为较大的一个；$r'$ 为 $r, s$ 中 $y$ 坐标较小的一个， $s'$为较大的一个，那么四边形的四个顶点按顺序为 $ v', u', r', s'$；
4. ​

### Chapter 7: 非中空多边形的凸四边形剖分

这部分介绍非中空多边形的线性时间动态规划算法。

由多边形区域的边和内部的弦(chord)共同分割形成的一组凸多边形 $q$ ，并给定凸多边形的权重 $\omega(q)$ ，一般来说，凸多边形的权重为欧式空间中的周长长度。而动态规划算法的目标则为，使得划分结果中的弦(chord)总长度最小。这也叫做“最小ink”划分。

对于具有一组弦 $C$ 的多边形区域 $P$ 的一条边 $e$ 。任何一条弦 $c$ 都会把这个多边形划分为两个非中空多边形；设 $P_c$ 为这两个新形成的多边形中不包含 $e$ 的那个多边形，$P_e=P$ 。对于所有 $c\in C\cup{e}$ ，将 $P_c$ 的凸四边形剖分的最小结果设为 $m(P_c)$ 。那么，对于所有 $k\in C\cup{e}$， $m(P_k)$  就是 $P_k$ 中全部凸四边形的最小值；同时，$m(P_k)$ 也相当于 $\omega(q) + \Sigma{m(P_c): c \neq k}$，其中 $c$ 是用来形成 $q$ 的弦。

因此，如果 $C\cup{e}$ 是部分排序(partially ordered)的，即，如果 $c_1$ 是 $P_{c_2}$ 的一条弦，那么 $c_1<c_2$ 。进而，对于 $c\in C\cup{e}$ ，$c$ 从最小到最大遍历时，就可以递归的找到一个 $P_c$的凸四边形剖分。

