### Chapter 6: Pseudo-Rectilinear Regions的凸四边形最优剖分算法

这部分介绍上一章介绍的Pseudo-Rectilinear Regions最优剖分算法的实现。

算法的时间复杂度下界为 $O(nlog n)$。算法的输入为组成多边形区域的多个多边形的链表，每个多边形由一组按顺时针顺序或者逆时针顺序排列的顶点组成。每个顶点的x坐标和y坐标都是整数值。同时，假设没有任意两条边交叉。

而验证一个多边形区域为Pseudo-Rectilinear Region的算法在[SH]这篇论文中可以找到，算法复杂度为 $O(nlog n)$。

算法的结果为一系列用于剖分的四边形，每个四边形由顺时针排列的四个顶点组成。

对于这样一个问题：找到一条左边 $(u, v)$，满足 $v$ 的右邻居在一条右边上。据上一章所讲，如果全部的左边按照右节点的x坐标进行排序，最靠右的左边的右顶点的右邻居一定在一条右边上。更进一步，当根据最后一条左边确定下来的凸四边形被删掉的时候，所有的左边都消失了，然后，最多有两条新的左边会被创建出来。

接下来，对于找右邻居的问题。在算法的过程中，右邻居有可能改变。定义顶点 $v$ 的initial right neighbour为，$v$ 节点右边节点中最靠左，同时与 $v$ 并没有通过倾斜边相连。

#### 引理 5

设删掉根据点对 $(u, v), (r, s)$ 确定的凸四边形后得到的一组不相交的pseudo-rectilinear regions为 $P'$ ，其中 $(u, v)$ 是一条左边，节点 $u$ 的x坐标小于 $v$ 的x坐标，$v$的右邻居为 $r$，而且 $(r, s)$ 是一条右边。如果 $v$ 是 $P'$ 中最右边的一个节点，那么 $v$ 在 $P'$ 的右邻居就是区域 $P$ 的 initial right neighbour。

对于一个给定的pseudo-rectilinear region，如果initial right neighbours的结果已经计算出来后，那么在算法中不需要再计算节点的右邻居。

#### 算法

步骤I：验证多边形区域 $P$ 为pseudo-rectilinear，找到 $P$ 中的 initial right neighbours。然后创建 $P$ 的左边的列表 $L$，根据右节点的 $x$ 坐标进行排序。

步骤II：重复以下步骤直到 $L$ 为空。

1. 从 $L$ 中删掉最后一个左边 $(u, v)$，其中 $u$ 的 $x$ 小于 $v$；
2. 令 $r$ 为节点 $v$ 的initial right neighbour，而且节点 $s$ 与 $r$ 通过一条斜边直接相连；
3. 根据边 $(u, v)$, $(r, s)$ 生成四边形的思路为：令 $u'$ 为节点 $u, v$中 $y$ 坐标较小的一个，$v'$ 为较大的一个；$r'$ 为 $r, s$ 中 $y$ 坐标较小的一个， $s'$为较大的一个，那么四边形的四个顶点按顺序为 $ v', u', r', s'$；
4. 如果 $(u',r')$ 并不是一条水平边，那么记录它已经变成了一条倾斜边 ，另外，如果节点 $u'$ 的 $y$ 坐标大于节点 $v'$ ，那么将 $(u', r')$ 作为一条新边添加到 $L$ 的尾部。如果 $(v', s')$ 并不是一条水平边，那么记录它已经变成了一条倾斜边。进一步的，如果节点 $v'$ 的 $y$ 坐标小于节点 $s'$ ，那么把 $(v', s')$ 作为一条新边添加到 $L$ 的尾部，但是，如果 $(u', r')$ 已经添加到 $L$ 中，并且 $s'$ 的 $x$ 坐标小于 $r'$ ，那么将 $(v', s')$ 置于 $(u', r')$ 的前面。

值得注意的是，在特定机器模型中，步骤II可以在线性时间内完成。

##### 算法实现

实现中使用了扫描线技术。首先对节点按照 $x$ 坐标进行排序，时间为 $O(n log{n})$ 。一条垂直的扫描线从 $x=-\infty$ 扫描至 $x=\infty$ ，在每次遇到节点时暂停。在扫描的过程中，将遇到的边加到一个有序序列中。而这个序列需要支持 $O(logm)$ 复杂度的元素删减操作，其中 $m$ 为序列的长度。

当扫描线自底向上扫描时，边成对进入并成对离开，将其称为“进出对” (in-out pair)。假设节点 $v$ 为扫描过程中下一个即将遇到的节点，那么节点 $v$ 有这样几种情况：A，位于一条边上；B，位于两条边上；C，位于一对“进出对”的边的中间；D，位于两条边中间，且这两条边属于不同的“进出对”。请看Figure14。

一旦知道节点 $v$ 相对于当前边序列的相对位置，边的序列需要及时的更新。在C，D两种情况中，两条新边需要加入到序列中；在情况A中，一条边被替换；在情况B中，两条边被删除。

在情况A，B和C中，节点 $v$ 所两侧属于同一“进出对”的两条边可能为某些节点带来 initial right neighbour 。以一条右边与节点 $v$ 连接的节点没有 initial right neighbour，而任何一个以一条左边与节点 $v$ 相连的节点可以继续等待一个 initial right neighbour。同时，在情况A，C和D中，节点 $v$ 自身也需要等待一个 initial right neighbour。

在扫描过程中，可以确认全部的左边，而这些左边也可以按照其右节点的 $x$ 坐标进行排序。

扫描过程的时间复杂度为 $O(n logn)$ 。

#### 引理5的证明

#### 定理6

在支持间接取址，分支，和基础数学运算的运行环境中，任何 $n-$节点 rectilinear region的凸四边形剖分算法，其时间复杂度为 $O(n logn)$ 。

#### 定理6的证明

### Chapter 7: 非中空多边形的凸四边形剖分

这部分介绍非中空多边形的线性时间动态规划算法。

由多边形区域的边和内部的弦(chord)共同分割形成的一组凸多边形 $q$ ，并给定凸多边形的权重 $\omega(q)$ ，一般来说，凸多边形的权重为欧式空间中的周长长度。而动态规划算法的目标则为，使得划分结果中的弦(chord)总长度最小。这也叫做“最小ink”划分。

对于具有一组弦 $C$ 的多边形区域 $P$ 的一条边 $e$ 。任何一条弦 $c$ 都会把这个多边形划分为两个非中空多边形；设 $P_c$ 为这两个新形成的多边形中不包含 $e$ 的那个多边形，$P_e=P$ 。对于所有 $c\in C\cup{e}$ ，将 $P_c$ 的凸四边形剖分的最小结果设为 $m(P_c)$ 。那么，对于所有 $k\in C\cup{e}$， $m(P_k)$  就是 $P_k$ 中全部凸四边形的最小值；同时，$m(P_k)$ 也相当于 $\omega(q) + \Sigma{m(P_c): c \neq k}$，其中 $c$ 是用来形成 $q$ 的弦。

因此，如果 $C\cup{e}$ 是部分排序(partially ordered)的，即，如果 $c_1$ 是 $P_{c_2}$ 的一条弦，那么 $c_1<c_2$ 。进而，对于 $c\in C\cup{e}$ ，$c$ 从最小到最大遍历时，就可以递归的找到一个 $P_c$的凸四边形剖分。

